syntax = "proto3";

import "aelf/core.proto";
import "aelf/options.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "callback_input.proto";
import "acs13.proto";

option csharp_namespace = "AElf.Contracts.Bridge";

service BridgeContract {
    option (aelf.csharp_state) = "AElf.Contracts.Bridge.BridgeContractState";
    option (aelf.base) = "acs13.proto";

    rpc Initialize (InitializeInput) returns (google.protobuf.Empty) {}

    rpc CreateBridge (CreateBridgeInput) returns (google.protobuf.Empty) {}

    //rpc Transfer (TransferInput) returns (google.protobuf.Empty) {}
    //rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {}
    //rpc Approve (ApproveInput) returns (google.protobuf.Empty) {}
    //rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {}
    //rpc Burn (BurnInput) returns (google.protobuf.Empty) {}

    rpc CreateSwap (CreateSwapInput) returns (aelf.Hash) {
    }
    rpc SwapToken (SwapTokenInput) returns (google.protobuf.Empty) {
    }
    rpc ChangeSwapRatio (ChangeSwapRatioInput) returns (google.protobuf.Empty) {
    }
    rpc Deposit (DepositInput) returns (google.protobuf.Empty) {
    }
    rpc Withdraw (WithdrawInput) returns (google.protobuf.Empty) {
    }
    rpc RecordMerkleTree (CallbackInput) returns (google.protobuf.Empty) {
    }

    // view methods
    
    rpc GetController (google.protobuf.Empty) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
    rpc GetBridgeTokenInfo (GetBridgeTokenInfoInput) returns (BridgeTokenInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetBalance (GetBalanceInput) returns (Balance) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowance (GetAllowanceInput) returns (Allowance) {
        option (aelf.is_view) = true;
    }
    rpc GetSwapInfo (aelf.Hash) returns (SwapInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetSwapPair (GetSwapPairInput) returns (SwapPair) {
        option (aelf.is_view) = true;
    }
    rpc GetSwapAmounts (GetSwapAmountsInput) returns (SwapAmounts) {
        option (aelf.is_view) = true;
    }
}

message InitializeInput {
    aelf.Address oracle_contract_address = 1;
    aelf.Address merkle_tree_recorder_contract_address = 2; 
    aelf.Address regiment_contract_address = 3; 
    int64 recorder_id = 4;
}

message CreateBridgeInput {
    BridgeTokenInfo origin_token_info = 1;
    string wrapped_token_symbol = 2;
}

message BridgeTokenInfo {
    string symbol = 1;
    string from_chain_name = 2;
    string bridge_type = 3;// ERC20, ERC721, ...
    string lock_contract_address = 4;
    bool is_native_token = 5;
}

message GetBridgeTokenInfoInput {

}

message ApproveInput {
    aelf.Address spender = 1;
    string symbol = 2;
    int64 amount = 3;
}

message UnApproveInput {
    aelf.Address spender = 1;
    string symbol = 2;
    int64 amount = 3;
}

message BurnInput {
    string symbol = 1;
    int64 amount = 2;
}

message GetBalanceInput {
    string symbol = 1;
    aelf.Address owner = 2;
}

message Balance {
    string symbol = 1;
    aelf.Address owner = 2;
    int64 balance = 3;
}

message GetAllowanceInput {
    string symbol = 1;
    aelf.Address owner = 2;
    aelf.Address spender = 3;
}

message Allowance {
    string symbol = 1;
    aelf.Address owner = 2;
    aelf.Address spender = 3;
    int64 allowance = 4;
}


message CreateSwapInput {
    int32 origin_token_size_in_byte = 1;
    bool origin_token_numeric_big_endian = 2;
    repeated SwapTargetToken swap_target_token_list = 3;
    int64 recorder_id = 4;
    aelf.Address regiment_address = 5;
}

message SwapTargetToken {
    string target_token_symbol = 1;
    SwapRatio swap_ratio = 2;
    int64 deposit_amount = 3;
}

message SwapInfo {
    aelf.Hash swap_id = 1;
    int32 origin_token_size_in_byte = 2;
    bool origin_token_numeric_big_endian = 3;
    map<string, aelf.Hash> swap_target_token_map = 4;
    aelf.Address regiment_address = 5;
    int64 recorder_id = 6;
}

message SwapPair {
    aelf.Hash swap_id = 1;
    int32 origin_token_size_in_byte = 2;
    bool origin_token_numeric_big_endian = 3;
    string target_token_symbol = 4;
    SwapRatio swap_ratio = 5;
    int64 swapped_amount = 6;
    int64 swapped_times = 7;
    int64 deposit_amount = 8;
}

message SwapRatio {
    int64 origin_share = 1;
    int64 target_share = 2;
}

message ChangeSwapRatioInput {
    aelf.Hash swap_id = 1;
    SwapRatio swap_ratio = 2;
    string target_token_symbol = 3;
}

message SwapTokenInput {
    aelf.Hash swap_id = 1;
    string origin_amount = 2;
    aelf.MerklePath merkle_path = 3;
    aelf.Hash unique_id = 4; // to make every swap unique 
    int64 last_leaf_index = 5;
}

message DepositInput {
    aelf.Hash swap_id = 1;
    string target_token_symbol = 2;
    int64 amount = 3;
}

message GetSwapPairInput {
    aelf.Hash swap_id = 1;
    string target_token_symbol = 2;
}

message GetSwapAmountsInput {
    aelf.Hash swap_id = 1;
    aelf.Hash unique_id = 2;
}

message SwapAmounts {
    aelf.Address receiver = 1;
    map<string, int64> received_amounts = 2;
}

message WithdrawInput {
    aelf.Hash swap_id = 1;
    string target_token_symbol = 2;
    int64 amount = 3;
}

// Events

message SwapRatioChanged {
    option (aelf.is_event) = true;
    aelf.Hash swap_id = 1;
    SwapRatio new_swap_ratio = 2;
    string target_token_symbol = 3;
}

message TokenSwapped {
    option (aelf.is_event) = true;
    aelf.Address address = 1;
    int64 amount = 2;
    string symbol = 3;
}

message BridgeCreated {
    option (aelf.is_event) = true;
    BridgeTokenInfo origin_token_info = 1;
    string wrapped_token_symbol = 2;
}

message SwapPairAdded {
    option (aelf.is_event) = true;
    aelf.Hash swap_id = 1;
}