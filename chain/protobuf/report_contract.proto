syntax = "proto3";

import "aelf/core.proto";
import "aelf/options.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "callback_input.proto";

option csharp_namespace = "AElf.Contracts.Report";

// the contract definition: a gRPC service definition.
service ReportContract {
    option (aelf.csharp_state) = "AElf.Contracts.Report.ReportContractState";

    rpc Initialize (InitializeInput) returns (google.protobuf.Empty) {}
  
    rpc QueryOracle (QueryOracleInput) returns (aelf.Hash) {}
  
    rpc CancelQueryOracle (aelf.Hash) returns (google.protobuf.Empty) {}
  
    rpc ConfirmReport (ConfirmReportInput) returns (google.protobuf.Empty) {}

    rpc RejectReport (RejectReportInput) returns (google.protobuf.Empty) {}

    rpc AdjustAmercementAmount (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}
  
    rpc ProposeReport (CallbackInput) returns (Report) {}
    
    rpc MortgageTokens (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}

    rpc WithdrawTokens (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}

    // Observer management.

    rpc ApplyObserver (google.protobuf.Empty) returns (google.protobuf.Empty) {}

    rpc QuitObserver (google.protobuf.Empty) returns (google.protobuf.Empty) {}

    rpc ProposeAdjustApplyObserverFee (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}

    rpc AdjustApplyObserverFee (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}
    rpc AdjustReportFee (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}
    
    // Offchain Aggregator Contract management.
    
    rpc RegisterOffChainAggregation (RegisterOffChainAggregationInput) returns (OffChainAggregationInfo) {}
    
    rpc AddRegisterWhiteList (aelf.Address) returns (google.protobuf.Empty) {}

    rpc RemoveFromRegisterWhiteList (aelf.Address) returns (google.protobuf.Empty) {}

    // Merkle tree style aggregator.
    
    rpc GetMerklePath (GetMerklePathInput) returns (aelf.MerklePath) {
        option (aelf.is_view) = true;
    }

    // View methods.
    
    rpc GetReport (GetReportInput) returns (Report) {
        option (aelf.is_view) = true;
    }
    rpc GetSignature (GetSignatureInput) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    rpc GetOffChainAggregationInfo (google.protobuf.StringValue) returns (OffChainAggregationInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetReportQueryRecord (aelf.Hash) returns (ReportQueryRecord) {
        option (aelf.is_view) = true;
    }
    rpc GetCurrentRoundId (google.protobuf.StringValue) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    rpc GetEthererumReport (GetEthererumReportInput) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    rpc GenerateEthererumReport (GenerateEthererumReportInput) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    rpc GetSignatureMap (GetSignatureMapInput) returns (SignatureMap) {
        option (aelf.is_view) = true;
    }
    rpc IsInRegisterWhiteList (aelf.Address) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
}

message InitializeInput {
    aelf.Address oracle_contract_address = 1;
    int64 report_fee = 2;
    int64 apply_observer_fee = 3;
    repeated aelf.Address initial_register_white_list = 4;
}

message QueryOracleInput {
    int64 payment = 1;
    string ethereum_contract_address = 2;
    int32 aggregate_threshold = 3;
    aelf.Address aggregator_contract_address = 4;
    int32 node_index = 5;
}

message ConfirmReportInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
    string signature = 3;
}

message RejectReportInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
    repeated aelf.Address accusing_nodes = 3;
}

message Report {
    aelf.Hash query_id = 1;
    int64 round_id = 2;
    Observations observations  = 3;
    bytes aggregated_data = 4;
    repeated ObserverList observers = 5;
}

message ReportQueryRecord {
    aelf.Address origin_query_sender = 1;
    int64 paid_report_fee = 2;
    bool is_rejected = 3;
}

message ObserverList {
    repeated aelf.Address value = 1;
}

message ProposeReportInput {
    repeated aelf.Hash query_id_list = 1;
}

message Observations {
    repeated Observation value = 1;
}

message Observation {
    string key = 1;
    bytes data = 2;
}

message GetSignatureInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
    aelf.Address address = 3;
}

message GetSignatureMapInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
}

message SignatureMap {
    map<string,string> value = 1;
}

message OffChainAggregationInfo {
    string ethereum_contract_address = 1;
    OffChainQueryInfoList off_chain_query_info_list = 2;
    aelf.Address observer_association_address = 3;
    bytes config_digest = 4;
    int32 aggregate_threshold = 5;
    aelf.Address aggregator_contract_address = 6;
    repeated int32 round_ids = 7;
}

message RegisterOffChainAggregationInput {
    ObserverList observer_list = 1;
    OffChainQueryInfoList off_chain_query_info_list = 2;
    string ethereum_contract_address = 3;
    bytes config_digest = 4;
    int32 aggregate_threshold = 5;
    aelf.Address aggregator_contract_address = 6;
}

message OffChainQueryInfo {
    string url_to_query = 1;
    repeated string attributes_to_fetch = 2;
}

message GetReportInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
}

message GetMerklePathInput {
    string ethereum_contract_address = 1;
    int64 round_id = 2;
    int32 node_index = 3;
}

message GetEthererumReportInput{
    string ethereum_contract_address = 1;
    int64 round_id = 2;
}

message GenerateEthererumReportInput{
    Report report = 1;
    bytes config_digest = 2;
    aelf.Address organization = 3;
}

message OffChainQueryInfoList {
    repeated OffChainQueryInfo value = 1;
}

// Events

message ReportProposed {
    option (aelf.is_event) = true;
    string raw_report = 1;
    aelf.Address observer_association_address = 2;
    string ethereum_contract_address = 3;
    int64 round_id = 4;
}

message ReportConfirmed {
    option (aelf.is_event) = true;
    int64 round_id = 1;
    string signature = 2;
    aelf.Address observer_association_address = 3;
    string ethereum_contract_address = 4;
}

message OffChainAggregationRegistered {
    option (aelf.is_event) = true;
    string ethereum_contract_address = 1;
    OffChainQueryInfoList off_chain_query_info_list = 2;
    aelf.Address observer_association_address = 3;
    bytes config_digest = 4;
    int32 aggregate_threshold = 5;
    aelf.Address aggregator_contract_address = 6;
}

message MerkleReportNodeAdded {
    option (aelf.is_event) = true;
    string ethereum_contract_address = 1;
    int32 node_index = 2;
    int64 node_round_id = 3;
    bytes aggregated_data = 4;
}